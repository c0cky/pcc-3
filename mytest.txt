rm -f pcc3 *.o y.tab.h y.output y.tab.c
gcc -g   -c -o main.o main.c
gcc -g   -c -o message.o message.c
gcc -g   -c -o symtab.o symtab.c
gcc -g   -c -o types.o types.c
gcc -g   -c -o bucket.o bucket.c
gcc -g   -c -o utils.o utils.c
bison -d -y gram.y
gcc -g -c y.tab.c
mv y.tab.o gram.o
flex scan.l
gcc -g -c lex.yy.c
rm lex.yy.c
mv lex.yy.o scan.o
gcc -g   -c -o backend-x86.o backend-x86.c
gcc -g   -c -o tree.o tree.c
gcc -g   -c -o expr.o expr.c
gcc -g main.o message.o symtab.o types.o bucket.o utils.o gram.o scan.o backend-x86.o tree.o expr.o -o pcc3
 #    2
 #    3
 #    4
 #    5
				# b_global_decl (i, alignment = 4, size = 4)
.globl i
	.data
	.align	4
	.type	i, @object
	.size	i, 4
i:
	.zero	4
				# b_global_decl (j, alignment = 4, size = 4)
.globl j
	.align	4
	.type	j, @object
	.size	j, 4
j:
	.zero	4
				# b_global_decl (pi, alignment = 4, size = 4)
.globl pi
	.align	4
	.type	pi, @object
	.size	pi, 4
pi:
	.zero	4
				# b_global_decl (ppi, alignment = 4, size = 4)
.globl ppi
	.align	4
	.type	ppi, @object
	.size	ppi, 4
ppi:
	.zero	4
 #    6
 #    7
				# b_global_decl (f, alignment = 4, size = 4)
.globl f
	.align	4
	.type	f, @object
	.size	f, 4
f:
	.zero	4
				# b_global_decl (pf, alignment = 4, size = 4)
.globl pf
	.align	4
	.type	pf, @object
	.size	pf, 4
pf:
	.zero	4
 #    8
 #    9
				# b_global_decl (c, alignment = 1, size = 1)
.globl c
	.align	1
	.type	c, @object
	.size	c, 1
c:
	.zero	1
				# b_global_decl (s1, alignment = 4, size = 4)
.globl s1
	.align	4
	.type	s1, @object
	.size	s1, 4
s1:
	.zero	4
				# b_global_decl (s2, alignment = 4, size = 4)
.globl s2
	.align	4
	.type	s2, @object
	.size	s2, 4
s2:
	.zero	4
 #   10
 #   11
				# b_global_decl (pppi, alignment = 4, size = 4)
.globl pppi
	.align	4
	.type	pppi, @object
	.size	pppi, 4
pppi:
	.zero	4
 #   12
 #   13
 #   14
 #   15
 #   16
				# b_func_prologue (main)
	.text
.global main
	.type	main, @function
main:
	pushl	%ebp
	movl	%esp, %ebp
	andl	$-16, %esp
 #   17
				# b_pop ()
	addl	$8, %esp
 #   18
				# b_pop ()
	addl	$8, %esp
 #   19
				# b_alloc_arglist (0 bytes)
	movl	%esp, %eax
	subl	$4, %esp
	andl	$-16, %esp
	movl	%eax, (%esp)
	subl	$0, %esp
				# b_funcall_by_name (print_ints, signed int)
	call	print_ints
	addl	$0, %esp
	movl	(%esp), %ecx
	movl	%ecx, %esp
	subl	$8, %esp
	movl	%eax, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   20
				# b_pop ()
	addl	$8, %esp
 #   21
				# b_alloc_arglist (0 bytes)
	movl	%esp, %eax
	subl	$4, %esp
	andl	$-16, %esp
	movl	%eax, (%esp)
	subl	$0, %esp
				# b_funcall_by_name (print_ints, signed int)
	call	print_ints
	addl	$0, %esp
	movl	(%esp), %ecx
	movl	%ecx, %esp
	subl	$8, %esp
	movl	%eax, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   22
				# b_pop ()
	addl	$8, %esp
 #   23
				# b_alloc_arglist (0 bytes)
	movl	%esp, %eax
	subl	$4, %esp
	andl	$-16, %esp
	movl	%eax, (%esp)
	subl	$0, %esp
				# b_funcall_by_name (print_ints, signed int)
	call	print_ints
	addl	$0, %esp
	movl	(%esp), %ecx
	movl	%ecx, %esp
	subl	$8, %esp
	movl	%eax, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   24
 #   25
				# b_push_ext_addr (f)
	subl	$8, %esp
	movl	$f, (%esp)
				# b_assign (float)
	movl	(%esp), %edx
	addl	$8, %esp
	movl	(%esp), %eax
	movl	%edx, (%eax)
	movl	%edx, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   26
				# b_pop ()
	addl	$8, %esp
 #   27
				# b_pop ()
	addl	$8, %esp
 #   28
				# b_alloc_arglist (0 bytes)
	movl	%esp, %eax
	subl	$4, %esp
	andl	$-16, %esp
	movl	%eax, (%esp)
	subl	$0, %esp
				# b_funcall_by_name (print_floats, signed int)
	call	print_floats
	addl	$0, %esp
	movl	(%esp), %ecx
	movl	%ecx, %esp
	subl	$8, %esp
	movl	%eax, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   29
 #   30
				# b_pop ()
	addl	$8, %esp
 #   31
				# b_alloc_arglist (0 bytes)
	movl	%esp, %eax
	subl	$4, %esp
	andl	$-16, %esp
	movl	%eax, (%esp)
	subl	$0, %esp
				# b_funcall_by_name (print_ints, signed int)
	call	print_ints
	addl	$0, %esp
	movl	(%esp), %ecx
	movl	%ecx, %esp
	subl	$8, %esp
	movl	%eax, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   32
 #   33
				# b_pop ()
	addl	$8, %esp
 #   34
				# b_pop ()
	addl	$8, %esp
 #   35
				# b_pop ()
	addl	$8, %esp
 #   36
				# b_pop ()
	addl	$8, %esp
 #   37
				# b_alloc_arglist (0 bytes)
	movl	%esp, %eax
	subl	$4, %esp
	andl	$-16, %esp
	movl	%eax, (%esp)
	subl	$0, %esp
				# b_funcall_by_name (print_ints, signed int)
	call	print_ints
	addl	$0, %esp
	movl	(%esp), %ecx
	movl	%ecx, %esp
	subl	$8, %esp
	movl	%eax, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   38
 #   39
				# b_pop ()
	addl	$8, %esp
 #   40
				# b_pop ()
	addl	$8, %esp
 #   41
				# b_pop ()
	addl	$8, %esp
 #   42
				# b_alloc_arglist (0 bytes)
	movl	%esp, %eax
	subl	$4, %esp
	andl	$-16, %esp
	movl	%eax, (%esp)
	subl	$0, %esp
				# b_funcall_by_name (print_ints, signed int)
	call	print_ints
	addl	$0, %esp
	movl	(%esp), %ecx
	movl	%ecx, %esp
	subl	$8, %esp
	movl	%eax, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   43
 #   44
				# b_pop ()
	addl	$8, %esp
 #   45
				# b_alloc_arglist (0 bytes)
	movl	%esp, %eax
	subl	$4, %esp
	andl	$-16, %esp
	movl	%eax, (%esp)
	subl	$0, %esp
				# b_funcall_by_name (print_ints, signed int)
	call	print_ints
	addl	$0, %esp
	movl	(%esp), %ecx
	movl	%ecx, %esp
	subl	$8, %esp
	movl	%eax, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   46
 #   47
				# b_pop ()
	addl	$8, %esp
 #   48
				# b_alloc_arglist (0 bytes)
	movl	%esp, %eax
	subl	$4, %esp
	andl	$-16, %esp
	movl	%eax, (%esp)
	subl	$0, %esp
				# b_funcall_by_name (print_ints, signed int)
	call	print_ints
	addl	$0, %esp
	movl	(%esp), %ecx
	movl	%ecx, %esp
	subl	$8, %esp
	movl	%eax, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   49
 #   50
				# b_pop ()
	addl	$8, %esp
 #   51
				# b_pop ()
	addl	$8, %esp
 #   52
				# b_alloc_arglist (0 bytes)
	movl	%esp, %eax
	subl	$4, %esp
	andl	$-16, %esp
	movl	%eax, (%esp)
	subl	$0, %esp
				# b_funcall_by_name (print_ints, signed int)
	call	print_ints
	addl	$0, %esp
	movl	(%esp), %ecx
	movl	%ecx, %esp
	subl	$8, %esp
	movl	%eax, (%esp)
				# b_pop ()
	addl	$8, %esp
 #   53
				# b_func_epilogue (main)
	leave
	ret
	.size	main, .-main
 #   54
